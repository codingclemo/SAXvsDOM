

import java.io.*;
import org.w3c.dom.*;
import org.xml.sax.*;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.*;

public class DOM {

  public static void main(String[] args) throws XPathExpressionException {

    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.setValidating(true);
    factory.setIgnoringElementContentWhitespace(true);
    factory.setExpandEntityReferences(false);
    factory.setIgnoringComments(false);

    try {
    	
    
      DocumentBuilder builder = factory.newDocumentBuilder();
      
      builder.setErrorHandler(new ErrorHandler() {
        // treat fatal errors
        public void fatalError(SAXParseException spe) throws SAXException {
          System.out.println("[Fatal Error] " + spe.getSystemId() + ", Line " + spe.getLineNumber() + ": "
              + spe.getLocalizedMessage());
          throw spe;
        }

        // treat validation errors
        public void error(SAXParseException spe) throws SAXParseException {
          System.out.println(
              "[Error] " + spe.getSystemId() + ", Line " + spe.getLineNumber() + ": " + spe.getLocalizedMessage());
          throw spe;
        }

        // dump warnings
        public void warning(SAXParseException spe) throws SAXParseException {
          System.out.println(
              "[Warning] " + spe.getSystemId() + ", Line " + spe.getLineNumber() + ": " + spe.getLocalizedMessage());
        }
      });

      // build DOM and do stuff here
      buildDOM(builder);

    } catch (ParserConfigurationException pce) {
      pce.printStackTrace();
    } catch (SAXParseException spe) {
      // Error generated by the parser
      System.out.println("[Error] " + spe.getSystemId() + ", Line " + spe.getLineNumber() + ": " + spe.getMessage());
      Exception x = spe;
      if (spe.getException() != null)
        x = spe.getException();
      x.printStackTrace();
    } catch (SAXException sxe) { // Error generated during parsing)
      Exception x = sxe;
      if (sxe.getException() != null)
        x = sxe.getException();
      x.printStackTrace();
    } catch (IOException ioe) { // I/O error
      ioe.printStackTrace();
    } catch (TransformerConfigurationException tce) {
      tce.printStackTrace();
    } catch (TransformerException te) {
      te.printStackTrace();
    }
  }

  private static void buildDOM (DocumentBuilder builder) throws IOException, 
  																TransformerConfigurationException,
  																TransformerException,
  																SAXException,
  																SAXParseException,
  																XPathExpressionException {
	  															
      File inputFile = new File("../size2mb.xml");
      File outputFile = new File("../size2mb_DOM.xml");
      System.out.println("**** DOM PARSER ****");
      Document doc = builder.parse(inputFile);

      int EmptyElements = 0, bookCount = 0, bookCountXML = 0, countPages = 0;
      double avgPrice = 0;
      
      long parsingTime = System.currentTimeMillis();
      NodeList helpList;
      Element helpElement;
      XPath xpath = XPathFactory.newInstance().newXPath();

      Element root = doc.getDocumentElement();
      NodeList entries = root.getChildNodes();

      for (int i = 0; i < entries.getLength(); i++) {
        Element entry = (Element) entries.item(i).getFirstChild();
        NodeList subentries = entry.getChildNodes();
        
        for (int j = 0; j < subentries.getLength(); j++) {
          Element buch = (Element) subentries.item(j).getFirstChild();
          
          if (buch.hasChildNodes()) {
            // remove ISBN in text
            helpList = buch.getElementsByTagName("ISBN");
            if (helpList.getLength() > 0) {
              helpElement = (Element) helpList.item(0);
              String isbnString = helpElement.getTextContent();
              if (isbnString.startsWith("ISBN:")) {
                isbnString = isbnString.substring(5);
                helpElement.setTextContent(isbnString);
              }
            }
            
            // count if the book has more than 500 pages
            helpList = buch.getElementsByTagName("Seiten");
            if (helpList.getLength() > 0) {
              helpElement = (Element) helpList.item(0);
              if (Integer.parseInt(helpElement.getTextContent()) > 500) {
                countPages++;
              }
            }

            // count booktitle if "Professional XML"
            helpList = buch.getElementsByTagName("Titel");
            if (helpList.getLength() > 0) {
              helpElement = (Element) helpList.item(0);
              if (helpElement.getTextContent().equals("Professional XML")) {
                bookCountXML++;
              }
            }

            // change dollars to euros
            helpList = buch.getElementsByTagName("Preis");
            if (helpList.getLength() > 0) {
              helpElement = (Element) helpList.item(0);
              if (helpElement.getAttribute("waehrung").toString().equals("Dollar")) {
                Text lnText = (Text) helpElement.getFirstChild();
                String lnString = lnText.getNodeValue();
                helpElement.setAttribute("waehrung", "Euro"); 
                double price = (Double.parseDouble(lnString));
                price = price / 1.06;
                helpElement.setTextContent(String.format("%1.2f",price).replaceAll(",", ".")); 
              }
              avgPrice += Double.parseDouble(helpElement.getTextContent());
            }
            // count books in general
            bookCount++;
          } 
        }
      }
      
      Element elemStatistic = doc.createElement("Statistik");
      Element elemAvgPrice = doc.createElement("Durchschnittspreis");
      Element elemPages = doc.createElement("Seiten");
      Element elemEmptyElements = doc.createElement("leereElemente");
      Element elemSales = doc.createElement("Verkaufszahlen");
    
      EmptyElements = Integer.parseInt(xpath.evaluate("count(//*[not(node())])", doc.getDocumentElement()));
      elemEmptyElements.appendChild(doc.createTextNode(String.valueOf(EmptyElements)));
      elemAvgPrice.setAttribute("gruppierung", Double.toString((double) avgPrice / bookCount));
      elemSales.setAttribute("buch", "Professional XML");
      elemSales.appendChild(doc.createTextNode(String.valueOf(bookCountXML)));
      elemPages.setAttribute("mehrAls", "500");
      
      elemPages.appendChild(doc.createTextNode(String.valueOf(String.valueOf(countPages))));
      elemStatistic.appendChild(elemEmptyElements);
      elemStatistic.appendChild(elemSales);
      elemStatistic.appendChild(elemAvgPrice);
      elemStatistic.appendChild(elemPages);
      root.appendChild(elemStatistic);

      TransformerFactory factory = TransformerFactory.newInstance();
      Transformer transformer = factory.newTransformer();
      DOMSource domSource = new DOMSource(doc);
      StreamResult streamResult = new StreamResult(new FileOutputStream(outputFile));

      transformer.setOutputProperty("doctype-system", "books.dtd");
      transformer.setOutputProperty("indent", "yes");
      transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
      transformer.transform(domSource, streamResult);

      parsingTime = System.currentTimeMillis() - parsingTime;
      System.out.println("Parsing is done and took " + parsingTime + " miliseconds. Output file is here:\n" + outputFile.getAbsolutePath());
  }
  
  
  /* Print Type of Node */
  @SuppressWarnings("unused")
  private static String printNodeType(short sNodeType) {
    switch (sNodeType) {
    case Node.ELEMENT_NODE:
      return "ELEMENT_NODE";
    case Node.ATTRIBUTE_NODE:
      return "ATTRIBUTE_NODE";
    case Node.TEXT_NODE:
      return "TEXT_NODE";
    case Node.CDATA_SECTION_NODE:
      return "CDATA_SECTION_NODE";
    case Node.ENTITY_REFERENCE_NODE:
      return "ENTITY_REFERENCE_NODE";
    case Node.ENTITY_NODE:
      return "ENTITY_NODE";
    case Node.PROCESSING_INSTRUCTION_NODE:
      return "PROCESSING_INSTRUCTION_NODE";
    case Node.COMMENT_NODE:
      return "COMMENT_NODE";
    case Node.DOCUMENT_NODE:
      return "DOCUMENT_NODE";
    case Node.DOCUMENT_TYPE_NODE:
      return "DOCUMENT_TYPE_NODE";
    case Node.DOCUMENT_FRAGMENT_NODE:
      return "ELEMENT_NODE";
    case Node.NOTATION_NODE:
      return "NOTATION_NODE";
    default:
      return "Unknown type";
    }
  }
}
